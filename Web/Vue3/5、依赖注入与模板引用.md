## 7.6：单文件组件`CSS`功能
默认情况下，写在`.vue`组件中的样式会全局生效，很容易造成多个组件之间的样式冲突问题

导致组件之间样式冲突的根本原因是：
1.  单页面应用程序中，所有组件的`DOM`结构，都是基于唯一的`index.html`页面进行呈现的
2.  每个组件中的样式，都会影响整个`index.html`页面中的`DOM`元素

### 7.6.1：组件作用域`CSS`
当`<style>`标签带有`scoped`属性的后：
1.  让下方的选择器的样式只作用在该组件中，或者子组件的根元素上该组件中的所有元素及子组件中的根元素会加上固定的属性（data-v-~）该 css 选择器都会自动添加固定的属性选择器（[data-v-~]）
2.  该组件的所有元素编译后会自带一个特定的属性
3.  该`<style scoped>`内的选择器，在编译后会自动添加特定的属性选择器
4.  子组件的根节点会同时被父组件的作用域样式和子组件的作用域样式影响，主要是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式,
```vue
<style scoped>
</style>
```

### 7.6.2：深度选择器  
处于scoped样式中的选择器如果想要做更“深度”的选择，即影响到子组件，可以使用:deep()这个伪类  
```vue
<style scoped> //编译前
    .a :deep(.b) { /* ... */ }	
</style>
```

```vue
<style> //编译后
    .a[data-v-f3f3eg9] .b { /* ... */ }
</style>
```

### 7.6.3：`CSS`中的`v-bind()`
1.  单文件组件的`<style>`标签支持使用`v-bind``CSS`函数将`CSS`的值链接到动态的组件状态
2.  这个语法同样也适用于`<script setup>`，且支持`JavaScript`表达式（需要用引号包裹起来）
3.  实际的值会被编译成哈希化的`CSS`自定义属性，因此`CSS`本身仍然是静态的
4.  自定义属性会通过内联样式的方式应用到组件的某个元素上，并且在源值变更的时候响应式地更新
```vue
<template>
    <button>普通按钮</button>

    <hr>
  背景色：<input v-model="btnTheme.backColor" type="color">
  文本色：<input v-model="btnTheme.textColor" type="color">
</template>

<script>
export default {
    data: () => ({
        btnTheme: {
            backColor: '#000000', // 背景色
            textColor: '#FFFFFF' // 文本色
        }
    })
}
</script>

<script setup>
import {reactive} from 'vue';
let btnTheme = reactive({ // 按钮主题
    backColor: '#000000', // 背景色
    textColor: '#FFFFFF' // 文本色
})
</script>

<style scoped>
button {
    /* 使用 v-bind() 可以使用该组件的中数据源，如果绑定的数据源值发生变化，则样式也会随着更新 */
    background-color: v-bind('btnTheme.backColor');
    color: v-bind('btnTheme.textColor');
}
</style>
```

## 7.7：依赖注入
如果有一个深层的子组件需要一个较远的祖先组件中的部分数据，如果实现呢？
1.  可使用`props`沿着组件链逐级传递下去，如图 7.1
![[Pasted image 20230417222449.png]]

2.  我们可在祖先组件使用`provide`提供数据，后代组件使用`inject`注入数据，如图 7.2
![[Pasted image 20230417222457.png]]
### 7.7.1：`provide`(提供)
**1、在应用层如何提供****：**
在应用层方面可通过`app.provide()`为后代提供数据
应用层提供数据
```vue
import { createApp } from 'vue'
const app = createApp({ })
app.provide('message', 'hello!') // message 注入名， 'hello' 值
```

**2、在组件中如何提供**
（1.  在选项式 API 中，可通过`provide`选项为后代提供数据
Provide 选项提供数据【选项式】
```
export default {
    // 为后代组件提供数据选项
    provide: { title: '博客!' } // message：注入名，'hello'：值
}
```

（2.  如果想访问到组件的实例`this`，`provide`必须采用函数的方式（不能用箭头函数），为保证注入方和供给方之间的响应性链接，必须借助组合式 API 中的`computed()`函数提供计算属性，还可以提供修改响应式数据的函数（响应式数据的修改，尽量放在同一个组件中，为了好维护）

Provide 函数选项提供数据【选项式】
```vue
export default {
    data: () => ({
        title: '博客',
        subtitle: '百万博主分享经验'
    }),
    methods: {
        changeSubtitle(sub) {
            this.subtitle = sub
        }
    },
    // 使用函数的形式，可以访问到组件的实例 `this`
    provide() {
        return {
            // 传递数据的值为数据源 title，此方式注入方和供给方之间没有响应性链接
            title: this.title,
            // 传递数据的值为数据源 subtitle，此方式注入方和供给方之间具有响应性链接
            subtitle: computed(() => this.subtitle),
            // 为后代组件提供修改响应式数据 subtitle 的函数
            changeSubtitle: this.changeSubtitle
        }
	}
}

```

【组合式】 API `<script setup>` 中，可通过`provide()`函数来为后代组件提供数据
使用 provide 函数提供数据
```vue
<script setup>
import { ref, provide } from 'vue'

const message = 'hello'
const title = ref('博客')
const subtitle = ref('百万博主分享经验')

function changeSubtitle(sub) {
    this.subtitle = sub
}

provide('message', message) // 提供固定数据
provide('title', title) // 提供响应式数据
provide('subtitle', subtitle) // 提供响应式数据
provide('changeSubtitle', changeSubtitle) // 为后代组件提供修改响应式数据 subtitle 的函数
</script>
```

**注意：**`provide`选项中通过`computed`函数提供的响应式的数据，需要设置
`app.config.unwrapInjectedRef = true`  //以保证注入会自动解包这个计算属性。
这将会在 Vue 3.3 后成为一个默认行为，而我们暂时在此告知此项配置以避免后续升级对代码的破坏性。在 3.3 后就不需要这样做了。

### 7.7.2：`inject`(注入)
1.  **在选项式 API 中**，可通过`inject`选项来声明需要注入祖先组件提供的数据，他们可以在`JS`中直接通过`this`来访问，在视图模板中也可直接访问
```
export default {
    // 注入祖先组件提供的数据
    inject: ['message', 'title', 'subtitle', 'changeSubtitle'] 
}
```

2.  `inject`采用对象的形式来注入祖先组件提供的数据有哪些好处？
	a.  可用本地属性名注入祖先组件提供的数据（如相同时，`from`选项可省略）
	b.  如果注入的数据并没有在祖先组件中提供，则会抛出警告，可采用`defalut`选项设置默认值来解决

inject 对象形式【选项式】
```vue
export default {
    // 注入祖先组件提供的数据
    inject: {
        c_message: { 
            from: 'message', // 注入的哪个数据
        },
        // 本地属性名和需要注入的数据名一致时，from 可省略
        title, // 普通数据
        c_subtitle: {from: 'subtitle'}, // 响应式数据
        c_changeSub: {from: 'changeSubtitle'}, // 修改响应式数据 subtitle 的函数
        c_content: {
            from: 'content', // 祖先组件并未提供 content，则会报警告
            default: '暂时还未有内容' // 设置默认值（可为函数等），解决警告问题
        } 
    }
}
```


**在组合式 API 中**，使用`inject()`函数的返回值来注入祖先组件提供的数据
1.  如果提供数据的值是一个`ref`，注入进来的会是该`ref`对象，和提供方保持响应式连接
2.  如果注入的数据并没有在祖先组件中提供，则会抛出警告，可在`provide()`函数的第二个参数设置默认值来解决
3.  他们可以在`JS`和视图模板中直接访问
```vue
<script setup>
import { inject } from 'vue'

const c_message = inject('message')
const title = inject('title')
const c_subtitle = inject('subtitle')
const c_changeSub = inject('changeSubtitle')
// 祖先组件并未提供 content，则会报警告，设置默认值来解决
const c_content = inject('content',  '暂时还未有内容') 
</script>
```
### 7.2.3：例子

main.js

Vue

复制代码

App.vue【选项式】

Footer.vue【选项式】

DeepChild.vue【选项式】

App.vue【组合式】

Footer.vue【组合式】

DeepChild.vue【组合式】




# 9：模板引用
如果我们需要直接访问组件中的底层`DOM`元素，可使用`vue`提供特殊的`ref`属性来访问

## 9.1：访问模板引用
1.  在视图元素中采用`ref`属性来设置需要访问的`DOM`元素
	a.  该`ref`属性可采用字符值的执行设置
	b.  该`ref`属性可采用`v-bind:`或`:ref`的形式来绑定函数，其函数的第一个参数则为该元素

2.  如果元素的`ref`属性值采用的是字符串形式
	a.  在选项式 API `JS`中，可通过`this.$refs`来访问模板引用
	b.  在组合式 API `JS`中，我们需要声明一个同名的`ref`变量，来获得该模板的引用

```vue
<template>
  账号输入框：<input ref="account" type="text"> <!-- ref 字符串值形式 -->
    <button @click="changeAccountInputStyle">改变账号输入框的样式</button>

    <hr>
  密码输入框：<input :ref="passwordRef" type="password"> <!-- ref 函数形式：元素渲染后，会立即执行该函数 -->
    <button @click="changePasswordInputStyle">改变密码输入框的样式</button>
</template>

<script>
export default {
    data: () => ({
        accountEl: null,
        passwordEl: null
    }),
    methods: {
        changeAccountInputStyle() {
            this.accountEl = this.$refs.account // 获取账号输入框的 DOM
            console.log(this.accountEl)
            this.accountEl.style = "padding: 15px"
            this.accountEl.className = "rounded"
            this.accountEl.focus()
        },
        passwordRef(el) {
            this.passwordEl = el  // el 元素是密码输入框
        },
        changePasswordInputStyle() {
            console.log(this.passwordEl)
            console.log(this.$refs) // 函数式声明的 ref，不会在this.$refs中获取
            this.passwordEl.style = "padding: 15px"
            this.passwordEl.className = "rounded"
            this.passwordEl.focus()
        },
    }
}
</script>

<script setup>
import {ref} from 'vue';
// 账号输入框
let account = ref(null) // ref 变量名和账号输入框中的 ref 属性值一样

function changeAccountInputStyle() {
    console.log(account.value)
    account.value.style = 'padding: 10px'
    account.value.className = 'rounded'
    account.value.focus()
}

// ------------------------------------------------------------------------
let passwordEl = ref(null) // 密码输入框元素

function passwordRef(el) {
    passwordEl.value = el // el 元素是密码输入框
}

function changePasswordInputStyle() {
    console.log(passwordEl.value)
    passwordEl.value.style = 'padding: 10px'
    passwordEl.value.className = 'rounded'
    passwordEl.value.focus()
}
</script>

<style>
.rounded {
    border-radius: 15px;
}
</style>
```

## 9.2：`v-for`中的模板引用
当在`v-for`中使用模板引用时：
1.  如果`ref`值是字符串形式，在元素被渲染后包含对应整个列表的所有元素【数组】
2.  如果`ref`值是函数形式，则会每渲染一个列表元素则会执行对应的函数【不推荐使用】
**注意：**需要`v3.2.25`及以上版本

```vue
<template>
    <ul>  <!-- 如果 ref 值是字符串形式，在元素被渲染后包含对应整个列表的所有元素【数组】 -->
        <li v-for="b in books" :key="b.id" ref="bookList">
            {{ b.name }}
        </li>
    </ul>
    <button @click="changeBookListStyle">点我查看 bookList</button>

    <hr>
    <ul> <!-- 如果ref值是函数形式，则会每渲染一个列表元素则会执行对应的函数【不推荐使用】 -->
        <li v-for="s in students" :key="s.id" :ref="studentsRef">
            {{ s.name }}
        </li>
    </ul>
</template>

<script>
export default {
    data: () => ({
        books: [
            {id: 1, name: '红楼梦'},
            {id: 2, name: '三国演义'},
            {id: 3, name: '水浒传'},
            {id: 4, name: '西游记'}
        ],
        students: [
            {id: 1, name: 'Jack'},
            {id: 2, name: 'Annie'},
            {id: 3, name: 'Tom'}
        ]
    }),
    methods: {
        changeBookListStyle() {
            console.log(this.$refs.bookList)
            this.$refs.bookList[2].style = 'color: red'
        },
        studentsRef(el) {
            console.log(el)
        }
    }
}
</script>

<script setup>
import {onMounted, ref} from 'vue';

let books = ref([ // 书本
    {id: 1, name: '海底两万里'},
    {id: 2, name: '骆驼祥子'},
    {id: 3, name: '老人与海'},
    {id: 4, name: '安徒生童话'},
])
let bookList = ref(null)

onMounted(() => {
    console.log(bookList.value); // 获取引用的 DOM 对象，并打印，发现那么是数组，
    bookList.value[2].className = 'error'
})
</script>
```

## 9.3：组件上的`ref`
模板引用也可以被用在一个子组件上；这种情况下引用中获得的值是组件实例
1.  如果子组件使用的是选项式 API ，默认情况下父组件可以随意访问该子组件的数据和函数，除非在子组件使用`expose`选项来暴露特定的数据或函数，`expose`值为字符串数组
2.  如果子组件使用的是组合式 API `<script setup>`，那么该子组件默认是私有的，则父组件无法访问该子组件，除非子组件在其中通过`defineExpose`宏采用对象形式显式暴露特定的数据或函数

```vue
<template> //父组件
    <h3>登陆界面</h3>

    <hr>
    <LoginVue ref="loginView"/>   <!-- 组件上的 ref 的值为该组件的实例 -->

    <hr>
    <button @click="showSonData">查看子组件中的信息</button>
</template>

<script>
import LoginVue from './组件上的ref--子.vue';

export default {
    components: {LoginVue},
    data: () => ({
        login_vue: null
    }),
    methods: {
        showSonData() {
            console.log(this.login_vue.account) // 访问子组件中的账号数据
            console.log(this.login_vue.password) // 访问子组件中的密码数据
            this.login_vue.toLogin() // 访问子组件中的去登陆函数
        }
    },
    mounted() {
        this.login_vue = this.$refs.loginView
    }
}
</script>

<script setup>
import {ref} from 'vue'
import LoginVue from './组件上的ref--子.vue';

let loginView = ref(null)

function showSonData() {
    console.log(loginView.value.account)  // 访问子组件的 acccount 数据
    console.log(loginView.value.password)  // 访问子组件的 password 数据
    loginView.value.toLogin() // 调用子组件的 toLogin 函数
}
</script>
```

```vue
<template> //子组件
  账号：<input v-model="account" type="text">
    <br>
  密码：<input v-model="password" type="text">
</template>

<script>
export default { // 选项式 API ，默认情况下父组件可以随意访问该子组件的数据和函数等
    data: () => ({
        account: 'Abc31510',
        password: '123321'
    }),
    methods: {
        toLogin() {
            console.log('登录中……');
        }
    },
    expose: ['account', 'toLogin'] // 只暴露指定数据、函数等
}
</script>

<script setup>
import {ref} from 'vue' // 组合式 API ，<script setup> 默认是私有的，父组件无法访问组件中的数据及函数

let account = ref('Abc31510')
let password = ref('123321')

function toLogin() {
    console.log('登录中……')
}

defineExpose({ // 将指定数据、函数等暴露出去
    account,
    toLogin
})
</script>
```




