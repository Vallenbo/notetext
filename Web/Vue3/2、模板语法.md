## 4.1：内容渲染指令

内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容

### 4.1.1：`v-text`

使用`v-text`指令，将数据采用纯文本方式填充其空元素中
```vue
<template>
    <!-- 使用v-text指令，将数据采用纯文本方式填充其空元素中 -->
    <div v-text="student.name"></div>
    <!-- v-text：以纯文本的方式显示数据 -->
    <div v-text="student.desc"></div>
    <!-- 下面的代码会报错：div 元素不是空元素 -->
    <!-- <div v-text="student.name">这是原始的div数据</div> -->
</template>

<script> //v-text【选项式】
export default {
    data: () => ({
        student: {
            name: 'Jack',
            desc: '<h3>我是来自中国的小朋友！</h3>'
        }
    })
}
</script>

<script setup> //v-text【选项式】
    import { reactive } from 'vue'

    let student = reactive({
        name: 'Jack',
        desc: '<h3>我是来自中国的小朋友！</h3>'
    })
</script>
```

### 4.1.2：`{{ }}`插值表达式

在元素中的某一位置采用纯文本的方式渲染数据
```vue
<template>  
<!-- 插值表达式：在元素中的某一位置采用纯文本的方式渲染数据 -->  
<div>这是一个 DIV 元素，{{ student.name }}，{{ student.desc }}</div>  
</template>  
  
<script> //{{ }} 插值表达式【选项式】  
export default {  
data: () => ({  
student: {  
name: 'Jack',  
desc: '<h3>我是来自中国的小朋友！</h3>'  
}  
})  
}  
</script>  
  
<script setup> //{{ }} 插值表达式【组合式】  
import {reactive} from 'vue'  
  
let student = reactive({  
name: 'Jack',  
desc: '<h3>我是来自中国的小朋友！</h3>'  
})  
</script>
```

### 4.1.3：`v-html`

使用`v-html`指令，将数据采用HTML语法填充其空元素中
```vue
<template>
    <!-- 使用v-html指令，将数据采用HTML语法填充其空元素中 -->
    <div v-html="student.name"></div>
    <!-- v-html：以 HTML 语法显示数据 -->
    <div v-html="student.desc"></div>
    <!-- 下面的代码会报错：div 元素不是空元素 -->
    <!-- <div v-html="student.name">这是原始的div数据</div> -->
</template>

<script>
export default { //v-html【选项式】
    data: () => ({
        student: {
            name: 'Jack',
            desc: '<h3>我是来自中国的小朋友！</h3>'
        }
    })
}
</script>

<script setup> //v-html【组合式】
import { reactive } from 'vue'

let student = reactive({
    name: 'Jack',
    desc: '<h3>我是来自中国的小朋友！</h3>'
})
</script>
```

## 4.2：`v-model`双向绑定指令
`v-model`双向数据绑定指令，视图数据和数据源同步

一般情况下`v-model`指令用在表单元素中：
1.  文本类型的`<input>`和`<textarea>`元素会绑定`value`属性并侦听`input`事件
2.  `<input type="checkbox">`和`<input type="radio">`会绑定`checked`属性并侦听`change`事件
3.  `<select>`会绑定`value`属性并侦听`change`事件


### 4.2.1：`v-model`的修饰符
![[Pasted image 20230417214658.png]]



## 4.3：`v-bind`属性绑定指令

-   响应式地绑定一个元素属性，应该使用`v-bind:`指令，简写为 `:`
-   如果绑定的值是`null`或者`undefined`，那么该属性将会从渲染的元素上移除
```vue
<template>  
<input v-model="picture.width" max="500" min="100" type="range">  

<!-- v-bind: 为 src 属性绑定指定的数据源 -->  
<img v-bind:src="picture.src" v-bind:width="picture.width">  
  
<!-- : 是 v-bind: 的缩写形式 -->  
<img :src="picture.src" :width="picture.width">  

<!-- 如果绑定的值是 null 或者 undefined，那么该属性将会从渲染的元素上移除 -->  
<button @click="picture.width = null">设置宽度为NULL</button>  
</template>  
  
<script setup>  
import {reactive} from 'vue'  
  
let picture = reactive({  
src: 'https://1.jpg', // 图像地址  
width: 200 // 显示宽度  
})  
</script>  
  
<script>  
export default {  
	data: () => ({  
		picture: {  
		width: 200,  
		src: 'https://up1.jpg'  
		} 
	})
}
</script>
```

### 4.3.1：动态绑定多个属性值

直接使用`:`来为元素绑定多个属性及其值

```vue
<template>  
	<button v-bind="attrs">  
	我是一个普通按钮  
	</button>  
</template>  
  
<script>  
export default {  
	name: 'App',  
	data: () => ({  
		attrs: {  
			class: 'redBack',  
			id: 'btnBorderBlue'  
		}  
	})  
}  
</script>  
  
<script setup>  
import {reactive} from 'vue'  
  
let attrs = reactive({  
	class: 'error',  
	id: 'borderBlue'  
})  
  
</script>  
  
<style>  
button {  
	padding: 10px 20px;  
}  
  
.redBack {  
	background-color: #d25e5e;  
	color: white;  
}  
  
#btnBorderBlue {  
	border: 2px solid #408ae5;  
}  
</style>
```
渲染结果：

`<button class="redBack" id="btnBorderBlue">我是一个普通按钮</button>`



### 4.3.2：绑定`class`和`style`属性

`class`和`style`可以和其他属性一样使用`v-bind`将它们和动态的字符串绑定；但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的；因此，`Vue`专门为`class`和`style`的`v-bind`用法提供了特殊的功能增强；除了字符串外，表达式的值也可以是对象或数组。

### 4.3.2.1：`class`属性绑定


**绑定对象**


**绑定数组**




### 4.3.2.2：`style`属性绑定

**绑定对象**



**绑定数组**



还可以给`:style`绑定一个包含多个样式对象的数组，这些对象会被合并后渲染到同一元素上

style 属性绑定数组（选项式 API 例子）



style 属性绑定数组（组合式 API 例子）



## 4.4：`v-if`条件渲染指令

### 4.4.1：`v-if`、`v-else-if`、`v-else`

1.  `v-if` 指令用于条件性地渲染元素；该内容只会在指令的表达式返回真值时才被渲染
2.  `v-else-if`提供的是相应于`v-if`的`else if`区块，它可以连续多次重复使用
3.  你也可以使用`v-else`为`v-if`添加一个`else`区块
4.  `v-else`和`v-else-if`指令必须配合`v-if`指令一起使用 ，否则它将不会被识别，而且语句块中间不能出现无关其他元素
5.  `v-if`支持在`<template>`元素上使用，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 `<template>`元素


```vue
<template>
  是否显示：<input v-model="isShow" type="checkbox">
  <!--v-if：指令表达式为真时才会渲染该元素，为true时会创建该元素，为false时会销毁该元素-->
    <h3 v-if="isShow">这是一个普通的标题标签</h3>

    <hr>
  年龄: <input v-model="age" max="100" min="0" type="range"> {{ age }}
  <!-- v-if：可以配合 v-else-if 和 v-else 来搭建多重判断条件，他们中间不要参杂无关紧要的元素 -->
    <h1 v-if="age < 18">未成年</h1>
    <h2 v-else-if="age < 35">青年</h2> <!-- <span>无关紧要的元素</span> -->
    <h3 v-else-if="age < 50">中年</h3>
    <h4 v-else>老年</h4>

    <hr>
  周几: <input v-model="week" max="7" min="1" type="range"> {{ week }}
  <!-- v-if：可以配合 template 元素使用，最后渲染的结果并不会包含这个 <template>元素 -->
    <template v-if="week == 1 || week == 3 || week == 5 || week == 7">
        <h1>可以游泳</h1>
    </template>
    <template v-else>
        <h1>不可以游泳</h1>
    </template>
</template>

<script setup>
import {ref} from 'vue'

let isShow = ref(false)  // 是否显示
let age = ref(20)  // 年龄
let week = ref(3)  // 周几
</script>

<script>
export default {
    data: () => ({
        isShow: false, // 是否显示
        age: 20, // 年龄
        week: 3 // 周几
    })
}
</script>
```


### 4.4.2：v-show
-   类似于v-if显示元素，
-   `v-show`按条件显示一个元素的指令
-   `v-show`会在 DOM 渲染中保留该元素
-   `v-show`仅切换了该元素上名为`display`的 CSS 属性
-   `v-show`不支持在`<template>`元素上使用，也不能和`v-else`搭配使用


### 4.4.3：v-if和v-show的区别

-   `v-if`是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建
-   `v-if`也是惰性的：如果在初次渲染时条件值为`false`，则不会做任何事；条件区块只有当条件首次变为`true`时才被渲染
-   `v-show`元素无论初始条件如何，始终会被渲染，只有 CSS`display`属性会被切换
-   `v-if`有更高的切换开销，而`v-show`有更高的初始渲染开销；如果需要频繁切换，则使用`v-show` 较好；如果在运行时绑定条件很少改变，则`v-if`会更合适

## 4.5：`v-on`事件绑定指令

我们可以使用`v-on:`指令 (简写为`@`) 来监听 DOM 事件，并在事件触发时执行对应的`JavaScript`
用法：v-on:click=""`或 `@click=""`

```vue
<template>
    <h3>当前音量：{{ volume }}</h3>
  <!-- v-on: 事件绑定 -->
    <button v-on:click="addVolume">添加音量</button>
    <button v-on:click="subVolume">减小音量</button>

    <hr>
  <!-- @ 是 v-on: 的缩写 -->
    <button @click="setVolume(0)">静音</button>
    <button @click="setVolume(5)">音量适中</button>
    <button @click="setVolume(10)">音量最大</button>
</template>

<script setup>
import {ref} from 'vue'

let volume = ref(5) // 音量[0, 10]
function addVolume() { // 增大音量
    if (volume.value !== 10) {// 如果音量没有在最高值，则添加音量
        volume.value++
    }
}

function subVolume() { // 减小音量
    if (volume.value !== 0) {// 如果音量没有在最小值，则减小音量
        volume.value--
    }
}

function setVolume(value) { // 设置音量 ，添加参数
    if (value >= 0 && value <= 10) {// 判断音量是否在取值范围之间
        volume.value = value
    }
}
</script>

<script>
export default {
    data: () => ({
        volume: 5  // 音量[0, 10]
    }),
    methods: {
        addVolume() { // 添大音量
            if (this.volume !== 10) {// 如果音量没有在最高值，则添加音量
                this.volume++
            }
        },

        subVolume() {  // 减小音量
            if (this.volume !== 0) { // 如果音量没有在最小值，则减小音量
                this.volume--
            }
        },

        setVolume(value) {// 设置音量
            if (value >= 0 && value <= 10) {// 判断音量是否在取值范围之间
                this.volume = value
            }
        }
    }
}
</script>
```



### 4.5.1：@click.事件修饰符
点击则会触发事件
冒泡事件，从外到内逐级传递

- 事件修饰符 说明
**.prevent** 阻止默认行为
**.stop** 阻止事件冒泡，在嵌套的元素内，组织由子元素向父元素传递
**.self** 事件触发只在当前元素有效，而不包含子元素，只有在`event.target`是当前元素自身时触发事件处理函数
**.capture** 以捕获模式触发当前的事件处理函数，有.capture的元素先产生冒泡事件
**.once** 绑定的事件只触发1次
**.passive** 向浏览器表明不阻止事件的默认行为

```vue
<template>
  <!-- .prevent 修饰符阻止了超链接的默认行为（跳转到百度页） -->
    <a href="http://www.baidu.com" @click.prevent="say('baiDu')">百度</a>

    <div class="divArea" @click="say('DIV')">
        <button @click.stop="say('BUTTON')">冒泡按钮</button> <!-- .stop：阻止产生冒泡事件 -->
    </div>

    <div class="divArea" @click.self="say('DIV')"> <!-- .self：只在该元素上触发事件有效，其子元素无效 -->
        <button>我是一普通的按钮</button>
    </div>

  <!-- .passive：先执行默认行为，不考虑执行的代码中是否包含 event.preventDefault() -->
    <a href="http://www.baidu.com" @click.passive="eventPrevent">百度</a>

  <!-- .self：只在该元素上触发事件有效，其子元素无效 -->
    <div class="divArea" @click.self="say('DIV')">
        <button>我是一普通的按钮</button>
    </div>

  <!-- .once：绑定的事件只触发一次 -->
    <button @click.once="say('BUTTON')">点我试一下</button>
</template>

<script>
export default {
    methods: {
        say(name) { // 打招呼
            window.alert('你好：' + name)
        },
        eventPrevent() {
            event.preventDefault() // 阻止事件默认行为
        }
    }
}
</script>

<script setup>
function say(name) { // 打招呼
    window.alert('你好：' + name)
}

function eventPrevent() { // 阻止事件默认行为
    event.preventDefault()
}
</script>

<style>
.divArea {
    padding: 30px;
    border: 2px solid blue;
}
</style>
```


### 4.5.2：@keydown.按键修饰符
键盘按下的包含以下按键则触发事件，
按键别名：`.enter`、`.tab`、`.esc`、`.space`、`.up`、`.down`、`.left`、`.right`、`.delete` (捕获`Delete`和`Backspace`两个按键)
系统修饰符：`.ctrl`、`.alt`、`.shift`、`.meta`
准确的修饰符：`.exact`

```vue
<template>
  按下的键中包含 Enter 键事件：
    <input type="text" @keydown.enter="showMessage('你按下了 Enter 键')">
    <hr>
  按下的键中包含 Shift Enter 键事件：
    <input type="text" @keydown.enter.shift="showMessage('你按下了 Shift + Enter 键')"/>
    <hr>
  按下的键只有 Shift Enter 键事件：
    <input type="text" @keydown.enter.shift.exact="showMessage('你只按下了 Shift + Enter 键')"/>
</template>

<script>
export default {
    methods: {
        showMessage(message) {  // 弹出消息
            window.alert(message)
        }
    }
}
</script>

<script setup>
function showMessage(message) { // 弹出消息
    window.alert(message)
}
</script>
```



### 4.5.3：@mousedown.鼠标按键修饰符
鼠标 + 键盘按键则触发事件，
鼠标按键修饰符：`.left`、`.right`、`.middle`

```vue
<template>
    <button @mousedown.right="showTest('按下的是鼠标右键')">鼠标右键按下</button> <!-- 鼠标右键按下 -->

    <hr>
    <button @click.middle="showTest('按下的是鼠标中键')">点击时，采用的是鼠标中键</button> <!-- 点击时，采用的是鼠标中键 -->

    <hr>
    <button @mousedown.left="showTest('按下的是鼠标左键')">鼠标左键按下</button> <!-- 鼠标左键按下 -->
</template>

<script setup>
function showTest(text) {
    window.alert(text)
}
</script>

<style>
button {
    border: none;
    padding: 15px 20px;
}

button:active {
    box-shadow: 0 0 5px grey;
}
</style>
```


## 4.6：`v-for`列表渲染指令
使用`v-for`指令基于一个数组来渲染一个列表

### 4.6.1：渲染数组
语法：
1.  `in`前一个参数：`item in items`  
    `item`：值  
    `items`：需要循环的数组
2.  `in`前两个参数：`(value, index) in items`  
    `value`：值  
    `index`：索引  
    `items`：需要循环的数组
```vue
<template>
  <!--item in itmes
      item：值，当前循环的数组值
      itmes：循环的数组 -->
    <h6>v-for 渲染数组， v-for="item in itmes"</h6>
    <ul>
        <li v-for="sub in subject">
            编号：{{ sub.id }} --- 名称：{{ sub.name }}
        </li>
    </ul>
</template>

<script setup>
import {ref} from 'vue'

let subject = ref([ // 课程
    {id: 1, name: 'Vue'},
    {id: 2, name: 'Java'},
    {id: 3, name: 'UI设计'},
    {id: 4, name: 'Hadoop'},
    {id: 5, name: '影视后期'},
])
</script>
```

### 4.6.2：渲染对象
使用`v-for`来遍历一个对象的所有属性，遍历的顺序会基于对该对象调用`Object.keys()`的返回值来决定

语法：
1.  `in`前一个参数：`value in object`  
    `value`：属性值  
    `items`：需要循环的对象
2.  `in`前两个参数：`(value, name) in object`  
    `value`：属性值  
    `name`：键  
    `items`：需要循环的对象
3.  `in`前三个参数：`(value, name, index) in object`  
    `value`：属性值  
    `name`：键  
    `index`：索引  
    `items`：需要循环的对象

```vue
<template>
<h6>v-for 渲染对象， v-for="value in object"</h6>
    <ul>
        <li v-for="value in student">
            {{ value }}
        </li>
    </ul>
</template>

<script setup>
import {ref} from 'vue'
import {reactive} from 'vue'

let subject = ref([ // 课程
    {id: 1, name: 'Vue'},
    {id: 2, name: 'Java'},
    {id: 3, name: 'UI设计'},
    {id: 4, name: 'Hadoop'},
    {id: 5, name: '影视后期'},
])

let student = reactive({
    styNum: '007', // 学号
    name: 'Jack', // 名字
    age: 18 //年龄
})
</script>
```

### 4.6.3：通过 key 管理状态
当列表的数据变化时，默认情况下，`vue`会尽可能的复用已存在的`DOM`元素，从而提升渲染的性能；但这种默认的性能优化策略，会导致有状态的列表无法被正确更新。

为了给`vue`一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲染的性能；此时，需要为每项提供一个唯一的`key`属性：

`key`的注意事项：
-   `key`的类型只能是`Number/String`
-   `key`值必须具有唯一性
-   建议循环的列表有一个属性当`key`（该属性的值在此列表中唯一）
-   不使用索引当`key`
-   建议使用`v-for`指令时一定要指定`key`的值

```vue
<template>
    <button @click.once="addSubject">添加课程（数组最前面）</button>

    <h3>不使用key值</h3>
    <ul>
        <li v-for="sub in subject">
            <input type="checkbox">
            {{ sub }}
        </li>
    </ul>

    <hr>
    <h3>使用索引当key值</h3>
    <ul>
        <li v-for="(sub, index) in subject" :key="index">
            <input type="checkbox">
            {{ sub }}
        </li>
    </ul>

    <hr>
    <h3>使用列表属性当key值（该属性必须再此列表中唯一）</h3>
    <ul>
        <li v-for="sub in subject" :key="sub.id">
            <input type="checkbox">
            {{ sub }}
        </li>
    </ul>
</template>

<script setup>
import {ref} from 'vue'

let subject = ref([ // 课程
    {id: 1, name: 'Vue'},
    {id: 2, name: 'Java'},
    {id: 3, name: 'Hadoop'}
])

function addSubject() { // 添加课程
    subject.value.unshift({id: 4, name: 'Python'}) // （数组最前面）添加
}
</script>

<script>
export default {
    data: () => ({
        subject: [
            {id: 1, name: 'Vue'},
            {id: 2, name: 'Java'},
            {id: 3, name: 'Hadoop'}
        ]
    }),
    methods: {
        addSubject() { // 添加课程
            this.subject.unshift({id: 4, name: 'Python'})  // （数组最前面）添加
        }
    }
}
</script>
```



