# 单元测试

## go test  工具

Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。

**go test 常用参数**

`-run=Split/chinese`：它对应一个正则表达式，只有函数名匹配上的测试函数才会被go test命令执行。
`-short `标识是否缩短运行时间
`-timeout go test `超时时间
`-v` 查看测试函数名称和运行时间

`-benchmem` 打印内存分配统计信息
`-blockprofile` 将阻塞数据写入到指定的文件
`-coverprofile` 将覆盖率信息写入到指定文件
`-cpuprofile`  CPU使用数据写入指定文件
`-memprofile` 内存数据写入到指定文件
`-mutexprofile` 将互斥锁信息写入到指定文件
`-outputdir` 指定输出目录
`-trace` 将执行跟踪信息写入到指定文件

`go test`命令是按照一定约定和组织测试指定目录下代码。
所有测试文件以`_test.go` 结尾
函数命名凡是`func TestXxx(*testing.T)`
初始化逻辑放到`TestMain(*testing.M)`主测试方法中

在包目录内，所有以`_test.go`为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。
在`*_test.go`文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。

| 类型     | 格式                  | 作用                           |
| -------- | --------------------- | ------------------------------ |
| 测试函数 | 函数名前缀为Test      | 测试程序的一些逻辑行为是否正确 |
| 基准函数 | 函数名前缀为Benchmark | 测试函数的性能                 |
| 示例函数 | 函数名前缀为Example   | 为文档提供示例文档             |

`go test`命令会遍历所有的`*_test.go`文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。

## 功能测试

### 测试函数

每个测试函数必须导入testing包，测试函数的基本格式（签名）如下：

```go
func TestName(t *testing.T){   //功能测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头
    // ... 
}
```

其中参数t用于报告测试失败和附加的日志信息。
`testing.T`的拥有的方法如下：

```go
func (c *T) Error(args ...interface{})					func (c *T) Errorf(format string, args ...interface{})
func (c *T) Fail()										func (c *T) FailNow()
func (c *T) Failed() bool								func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})	func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})	func (c *T) Name() string
func (t *T) Parallel()									func (t *T) Run(name string, f func(t *T)) bool
func (c *T) Skip(args ...interface{})					func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})	func (c *T) Skipped() bool
```



### 测试组

当需要测试多组数据时。创建一组测试用例，通过`for range `循环，用来测试指定函数

```go
func TestSplit(t *testing.T) {    // 定义一个测试用例类型
	type test struct {
		input string
		sep   string
		want  []string
	}
	
	tests := []test{ // 定义一个存储测试用例的切片
		{input: "a:b:c", sep: ":", want: []string{"a", "b", "c"}},
		{input: "a:b:c", sep: ",", want: []string{"a:b:c"}},
		{input: "abcd", sep: "bc", want: []string{"a", "d"}},
		{input: "沙河有沙又有河", sep: "沙", want: []string{"河有", "又有河"}},
	}
	
	for _, tc := range tests { // 遍历切片，逐一执行测试用例
		got := Split(tc.input, tc.sep) //测试一下split函数对中文字符串的支持
		if !reflect.DeepEqual(got, tc.want) {
			t.Errorf("expected:%#v, got:%#v", tc.want, got)
		}
	}
}
```

```sh
split $ go test -v
=== RUN   TestSplit
--- FAIL: TestSplit (0.00s)
    split_test.go:42: expected:[]string{"河有", "又有河"}, got:[]string{"", "河有", "又有河"}
FAIL
exit status 1
FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
```



### 子测试

​	//在测试用例比较多的时候，我们没办法一眼看出来具体是哪个测试用例失败了
我们可以通过`-run=RegExp`来指定运行的测试用例，还可以通过`"/"`来指定要运行的子测试用例

```go
func TestSplit(t *testing.T) {
	type test struct { // 定义test结构体
		input string
		sep   string
		want  []string
	}
	tests := map[string]test{ // 测试用例使用map存储
		"simple":      {input: "a:b:c", sep: ":", want: []string{"a", "b", "c"}},
		"wrong sep":   {input: "a:b:c", sep: ",", want: []string{"a:b:c"}},
		"more sep":    {input: "abcd", sep: "bc", want: []string{"a", "d"}},
		"leading sep": {input: "沙河有沙又有河", sep: "沙", want: []string{"河有", "又有河"}},
	}
	for name, tc := range tests {
		t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试
			got := Split(tc.input, tc.sep)
			if !reflect.DeepEqual(got, tc.want) {
				t.Errorf("expected:%#v, got:%#v", tc.want, got)
			}
		})
	}
}
```

```go
例如：go test -v -run=Split/simple //只会运行simple对应的子测试用例。
```



## 测试覆盖率
​	指代码被测试套件覆盖的百分比。通常使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。
Go提供内置功能来检查你的代码覆盖率，使用go test -cover来查看测试覆盖率。例如：

```shell
split $ go test -cover
PASS
coverage：100.0% of statements
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s
```

从上面的结果可以看到我们的测试用例覆盖了100%的代码。

Go还提供了一个额外的-coverprofile参数，用来将覆盖率相关的记录信息输出到一个文件。例如：

```shell
split $ go test -cover -coverprofile=c.out
PASS
coverage：100.0% of statements
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s
```

上面的命令会将覆盖率相关的信息输出到当前文件夹下面的c.out文件中，
然后我们执行`go tool cover -html=c.out`，使用cover工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。
<img src="assets/Pasted image 20230424000202.png" alt="Pasted image 20230424000202" style="zoom：67%;" />


## 性能基准测试
基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试函数格式如下：

```go
func BenchmarkName(b *testing.B){ // 基准测试以Benchmark为前缀 ，需要一个*testing.B类型的参数b
// ...} 
```

基准测试必须要执行b.N次（至少跑够1s），这样的测试才有对照性
b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。

testing.B拥有的方法如下：

```go
func (c *B) Error(args ...interface{})					
func (c *B) Errorf(format string, args ...interface{})
func (c *B) Fail()											func (c *B) FailNow()
func (c *B) Failed() bool									func (c *B) Fatal(args ...interface{})
func (c *B) Fatalf(format string, args ...interface{})		func (c *B) Log(args ...interface{})
func (c *B) Logf(format string, args ...interface{})		func (c *B) Name() string
func (b *B) ReportAllocs()									func (b *B) ResetTimer()
func (b *B) Run(name string, f func(b *B)) bool				func (b *B) RunParallel(body func(*PB))
func (b *B) SetBytes(n int64)								func (b *B) SetParallelism(p int)
func (c *B) Skip(args ...interface{})						func (c *B) SkipNow()
func (c *B) Skipf(format string, args ...interface{})		func (c *B) Skipped() bool
func (b *B) StartTimer()									func (b *B) StopTimer()
```



### 基准测试用例

基准测试并不会默认执行，需要增加-bench参数，所以我们通过执行go test -bench=Split命令执行基准测试，输出结果如下：

```shell
split $ go test -bench=Split
goos：darwin
goarch：amd64
pkg：github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               203 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.255s
```

其中`BenchmarkSplit-8`表示对Split函数进行基准测试，数字8表示GOMAXPROCS的值，这个对于并发基准测试很重要。1`0000000和203ns/op`表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。
我们还可以为基准测试添加`-benchmem`参数，来获得内存分配的统计数据。

```shell
split $ go test -bench=Split -benchmem
goos：darwin
goarch：amd64
pkg：github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               215 ns/op             112 B/op          3 allocs/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.394s
```

其中，`112 B/op`表示每次操作内存分配了112字节，`3 allocs/op`则表示每次操作进行了3次内存分配。
使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。



## 性能测试

基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，

​	**比如**同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。

性能比较函数通常是一个带有参数的函数，被多个不同的`Benchmark`函数传入不同的值来调用。
函数名以benchmark开头，举个例子如下：

```go
func benchmark(b *testing.B, size int){/* ... */}
func Benchmark10(b *testing.B){ benchmark(b, 10) }
func Benchmark100(b *testing.B){ benchmark(b, 100) }
func Benchmark1000(b *testing.B){ benchmark(b, 1000) }
```

基准测试并不会默认执行，需要增加`-bench`参数，通过执行`go test -bench=Split`命令执行基准测试，`-benchmem`参数，来获得内存分配的统计数据
输出结果如下：

```shell
split $ go test -bench=Split -benchmem
goos：darwin
goarch：amd64
pkg：github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               215 ns/op             112 B/op          3 allocs/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.394s
```

`ns/op`每次操作执行时间ns纳秒
`BenchmarkSplit-8`：表示对Split函数进行基准测试		`数字8`：表示GOMAXPROCS的值，这个对于并发基准测试很重要。
`10000000和203ns/op`：表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。
`112 B/op`：表示每次操作内存分配了112字节，		3 allocs/op：则表示每次操作进行了3次内存分配。

```shell
split $ go test -bench=.   //运行所有的基准测试
```

默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。

最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用-benchtime标志增加最小基准时间，以产生更准确的结果。例如：

```shell
split $ go test -bench=Fib40 -benchtime=20s
goos：darwin
goarch：amd64
pkg：github.com/Q1mi/studygo/code_demo/test_demo/fib
BenchmarkFib40-8              50         663205114 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 33.849s
```

这一次BenchmarkFib40函数运行了50次，结果就会更准确一些了。

## 模糊测试

fuzz运行匹配的模糊测试用例
fuzztime指定模糊测试时长，默认一直运行
list列出匹配的顶层测试用例

## 重置时间

`b.ResetTimer`之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。

## 并行测试

`-Parallel`参数 ，可以指定性能测试时并行cpu数量

```go
func (b *B) RunParallel(body func(*PB))// 会以并行的方式执行给定的基准测试。
```

RunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与`-cpu`指定核心数一同使用。
执行一下基准测试：

```sh
split $ go test -bench=.
goos：darwin
goarch：amd64
pkg：github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8                10000000               131 ns/op
BenchmarkSplitParallel-8        50000000                36.1 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       3.308s
```

还可以通过在测试命令后添加-cpu参数如`go test -bench=. -cpu 1`来指定使用的CPU数量。

# Setup与TearDown

测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。

### TestMain

通过在`*_test.go`文件中定义TestMain函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。
如果测试文件包含函数:`func TestMain(m *testing.M)`那么生成的测试会先调用` TestMain(m)`，然后再运行具体测试。TestMain运行在主goroutine中, 可以在调用 `m.Run`前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用m.Run的返回值作为参数调用`os.Exit`。
一个使用TestMain来设置Setup和TearDown的示例如下：


需要注意的是：在调用TestMain时,` flag.Parse`并没有被调用。所以如果TestMain 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用`flag.Parse`。

### 子测试的Setup与Teardown

有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。

```go
func setupTestCase(t *testing.T) func(t *testing.T) { // 测试集的Setup与Teardown
	t.Log("如有需要在此执行:测试之前的setup")
	return func(t *testing.T) {
		t.Log("如有需要在此执行:测试之后的teardown")
	}
}

func setupSubTest(t *testing.T) func(t *testing.T) { // 子测试的Setup与Teardown
	t.Log("如有需要在此执行:子测试之前的setup")
	return func(t *testing.T) {
		t.Log("如有需要在此执行:子测试之后的teardown")
	}
}
```

使用方式如下：

```go
func TestSplit(t *testing.T) {
	type test struct { // 定义test结构体
		input string
		sep   string
		want  []string
	}
	tests := map[string]test{ // 测试用例使用map存储
		"simple":      {input: "a:b:c", sep: ":", want: []string{"a", "b", "c"}},
		"wrong sep":   {input: "a:b:c", sep: ",", want: []string{"a:b:c"}},
		"more sep":    {input: "abcd", sep: "bc", want: []string{"a", "d"}},
		"leading sep": {input: "沙河有沙又有河", sep: "沙", want: []string{"", "河有", "又有河"}},
	}
	teardownTestCase := setupTestCase(t) // 测试之前执行setup操作
	defer teardownTestCase(t)            // 测试之后执行testdoen操作

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试
			teardownSubTest := setupSubTest(t) // 子测试之前执行setup操作
			defer teardownSubTest(t)           // 测试之后执行testdoen操作
			got := Split(tc.input, tc.sep)
			if !reflect.DeepEqual(got, tc.want) {
				t.Errorf("expected:%#v, got:%#v", tc.want, got)
			}
		})
	}
}
```

测试结果如下：

```bash
split $ go test -v
=== RUN   TestSplit
=== RUN   TestSplit/simple
=== RUN   TestSplit/wrong_sep
=== RUN   TestSplit/more_sep
=== RUN   TestSplit/leading_sep
--- PASS: TestSplit (0.00s)
    split_test.go:71: 如有需要在此执行:测试之前的setup
    --- PASS: TestSplit/simple (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/wrong_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/more_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/leading_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    split_test.go:73: 如有需要在此执行:测试之后的teardown
=== RUN   ExampleSplit
--- PASS: ExampleSplit (0.00s)
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
```

### 示例函数的格式
被go test特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。

```go
func ExampleName() {  ...} //标准格式
```

为你的代码编写示例代码有如下三个用处：
1、示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。
2、示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。

```sh
split $ go test -run Example
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
```

3、示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为`strings.ToUpper`函数在Playground的示例函数效果。
<img src="assets/Pasted image 20230424000321.png" alt="Pasted image 20230424000321" style="zoom:67%;" />

# 性能调优pprof

​	在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。 Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库，这篇文章就要讲解怎么在 golang 中做 profiling。

**性能分析的5个方面:**

`I/O`：IO使用情况
`CPU profile`：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据
`Memory Profile（Heap Profile）`：报告程序的内存使用情况
`Block Profiling`：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈
`Goroutine Profiling`：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的
`deadlock`：死锁检测，数据竞争分析



web采集数据
通过基准测试采集数据
硬编码采集数

## 采集性能数据

Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：
`runtime/pprof`：采集工具型应用运行数据进行分析
`net/http/pprof`：采集服务型应用运行时数据进行分析

pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取各个函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。
注意，我们只应该在性能测试的时候才在代码中引入pprof。

## 工具型应用
如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用runtime/pprof库。 首先在代码中导入runtime/pprof工具：

**CPU性能分析**
开启CPU性能分析：`pprof.StartCPUProfile(w io.Writer)`
停止CPU性能分析：`pprof.StopCPUProfile()`
应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用`go tool pprof`工具进行CPU性能分析。

**内存性能优化**
记录程序的堆栈信息`pprof.WriteHeapProfile(w io.Writer)`
得到采样数据之后，使用`go tool pprof`工具进行内存性能分析。
`go tool pprof`默认是使用`-inuse_space`进行统计，还可以使用`-inuse-objects`查看分配对象的数量。

## 服务型应用

如果你的应用程序是一直运行的，比如 web 应用，那么可以使用net/http/pprof库，它能够在提供 HTTP 服务进行分析。
如果使用了默认的`http.DefaultServeMux`（通常是代码直接使用 `http.ListenAndServe(“0.0.0.0:8000”, nil)`），只需要在你的web server端代码中按如下方式导入net/http/pprof

```go
import _ "net/http/pprof"
```

如果你使用自定义的 Mux，则需要手动注册一些路由规则：

```go
r.HandleFunc("/debug/pprof/", pprof.Index)
r.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
r.HandleFunc("/debug/pprof/profile", pprof.Profile)
r.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
r.HandleFunc("/debug/pprof/trace", pprof.Trace)
```

如果你使用的是gin框架，那么推荐使用`github.com/gin-contrib/pprof`，在代码中通过以下命令注册pprof相关路由。
`pprof.Register(router)`
不管哪种方式，你的 HTTP 服务都会多出`/debug/pprof`，访问它会得到类似下面的内容：
<img src="assets/Pasted image 20230424094737.png" alt="Pasted image 20230424094737" style="zoom:67%;" />

这个路径下还有几个子页面：

> /debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载
> /debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件
> /debug/pprof/block：block Profiling 的路径
> /debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系

## go tool pprof命令
不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用go tool pprof命令行工具。
`go tool pprof`最简单的使用方式为:`go tool pprof [binary] [source]`

> binary 是应用的二进制文件，用来解析各种符号；
> source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。

注意事项： 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。

通过flag我们可以在命令行控制是否开启CPU和Mem的性能分析。 将上面的代码保存并编译成runtime_pprof可执行文件，执行时加上-cpu命令行参数如下：

```sh
./runtime_pprof -cpu
```

等待30秒后会在当前目录下生成一个cpu.pprof文件

未完。。。

