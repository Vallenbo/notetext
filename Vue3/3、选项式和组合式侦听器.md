## 5.1：选项式 API 中的侦听器

在选项式 API 中，我们可以使用`watch`选项在每次响应式属性发生变化时触发一个函数

### 5.1.1：函数式侦听器

在`watch`选项中声明的函数即为函数式侦听器，其中函数名就是要侦听的数据源，函数中的参数1为新数据值，参数2为旧数据值

### 5.1.2：对象式侦听器

在`watch`选项中声明的对象即为对象式侦听器，对象名就是要侦听的数据源，其中对象里的`handler`函数为数据源发生变化后需要执行的代码块，其参数1为新数据值，参数2为旧数据值



#### 5.1.2.1：`deep`

-   `watch`默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数，而嵌套属性的变化不会触发
-   如果想侦听所有嵌套的变更，你需要深层侦听器`deep: true`选项
-   深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大




#### 5.1.2.2：`immediate`

watch 默认是懒执行的：仅当数据源变化时，才会执行回调；但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调，可采用`immediate: true`选项










#### 5.1.2.3：`flush`

-   默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用；这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。
-   如果想在侦听器回调中能访问被 Vue 更新之后的DOM，你需要指明`flush: 'post'`选项









### 5.1.3：`this.$watch` 侦听器

#### 5.1.3.1：创建侦听器

使用组件实例的`$watch()`方法来命令式地创建一个侦听器；它还允许你提前停止该侦听器

语法：`this.$watch(data, method, object)`

1.  `data`：侦听的数据源，类型为`String`
2.  `method`：回调函数，参数一新值，参数二旧值
3.  `object`：配置

1.  `deep`：深度侦听
2.  `immediate`：创建时立即触发
3.  `flush: 'post'`：更改回调机制（`DOM`更新后）


#### 5.1.3.2：停止侦听器

需要自行停止侦听器，这时可以调用`$watch()` API 返回的函数


## 5.2：组合式 API 中的侦听器

在组合式API中，我们可以使用`watch`函数或者`watchEffect`函数在每次响应式状态发生变化时触发对应的回调函数




### 5.2.1：`watch()`函数

#### 5.2.1.1：创建侦听器

语法：`watch(source, callback, options)`

1.  `source`：需要侦听的数据源，可以是`ref`(包括计算属性)、一个响应式对象、一个 `getter`函数、或多个数据源组成的数组
2.  `callback`：回调函数

1.  侦听单个数据源：回调函数的第一个参数为新值，第二个参数为旧值
2.  侦听多个数据源组成的数组：一个参数数组是新值，第二个参数数组是旧值

3.  `options`：配置，`Object`类型

1.  `deep: true`：深度侦听，一般用在侦听的是`getter`函数返回的对象
2.  `immediate: true`：创建好侦听器立即执行
3.  `flush: 'post'`：更改回调的触发机制（`Dom`更新后）



#### 5.2.1.2：停止侦听器

停止侦听器：调用`watch()`返回的函数即可



### 5.2.2：`watchEffect()`函数

`watchEffect()`会立即执行一遍回调函数，如果这时函数产生了副作用，Vue 会自动追踪副作用的依赖关系，自动分析出响应源





#### 5.2.2.1：回调的触发时机

默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用；这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。

如果想在侦听器回调中能访问被 Vue 更新之后的DOM，你需要指明`flush: 'post'` 选项，或者你也可以使用更方便的别名`watchPostEffect()`函数


#### 5.2.2.2：停止侦听器

要手动停止一个侦听器，请调用`watchEffect`或`watchPostEffect()`返回的函数




# 6：计算属性

模板中的表达式虽然方便，但也只能用来做简单的操作；如果在模板中写太多逻辑，会让模板变得臃肿，难以维护；因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑

1.  选项式 API 中，可以提供`computed`选项来声明计算属性
2.  组合式 API 中，可以通过`computed`回调函数返回的值来声明计算属性




计算属性【选项式】

计算属性【组合式】




**计算属性与方法的区别：**

-   两种方式在结果上确实是完全相同的，不同之处在于计算属性值会基于其响应式依赖被缓存。
-   一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要所依赖的数据源不改变，无论多少次访问计算属性都会立即返回先前的计算结果，而不用重复执行`getter`函数。
-   方法调用总是会在重新渲染发生时再次执行函数。

**计算属性注意事项：**

-   不要在计算函数中做异步请求或者更改`DOM`
-   避免直接修改计算属性值




