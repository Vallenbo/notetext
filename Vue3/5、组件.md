# 7：组件

## 7.1：注册组件

一个`Vue`组件在使用前需要先被“注册”，这样`Vue`才能在渲染模板时找到其对应的实现；组件注册有两种方式：全局注册、局部注册


### 7.1.1：全局注册

可使用`app.component(name, Component)` 注册组件的方法，在此应用的任意组件的模板中使用

-   `name`：注册的名字
-   `Component`：需要注册的组件

需要全局注册的组件 Login.vue【选项式】

需要全局注册的组件 Login.vue【组合式】

main.js 中全局注册组件

我们使用注册的组件


### 7.1.2：局部注册

局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用

在选项式 API 中，我们可以使用`components`选项来局部注册组件


需要局部注册的组件 Login.vue【选项式】


局部注册【选项式】




在组合式 API 中的`<script setup>`内，直接导入的组件就可以在模板中直接可用，无需注册


需要局部注册的组件 Login.vue【组合式】



局部注册【组合式】


## 7.2：传递数据【父 -> 子】

如果父组件向子组件进行传递数据，那么我们需要在子组件中声明`props`来接收传递数据的属性，可采用字符串数组式或对象式来声明`props`

父组件向子组件传递数据，在使用组件的标签上采用属性方式传递的`props`值，可使用`v-bind:`或`:`来绑定属性

组件中`props`中的数据是只读的，不可直接更改，只能通过父组件进行更改

**声明与使用**

1.  在选项式 API 中

1.  我们可以提供`**props**`选项来声明接收传递的数据
2.  在`JS`中可使用`**this.$props**`来访问声明的自定义的属性
3.  在视图模板中，可直接访问`**props**`中声明的自定义属性

2.  在组合式 API 中

1.  我们可以采用`**defineProps**`宏来声明接收传递的数据
2.  在`JS`中可使用`**defineProps**`返回的对象来访问声明的自定义的属性
3.  在视图模板中，可直接访问`**defineProps**`中声明的自定义属性



#### 7.2.1：字符串数组的形式



字符串数组的形式【选项式】


字符串数组的形式【组合式】



例子：

需要注册的组件 Button.vue【选项式】

父组件使用 Button.vue 组件【选项式】

需要注册的组件 Button.vue【组合式】

父组件使用 Button.vue 组件【组合式】



#### 7.2.2：对象的形式

对象形式声明的`props`，可以对传来的值进行校验，如果传入的值不满足类型要求，会在浏览器控制台中抛出警告来提醒使用者

对象形式声明的`props`，`key`是`prop`的名称，值则为约束的条件

**对象中的属性：**

`**type**`：类型，如`String`、`Number`、`Boolean`、`Array`、`Object`、`Date`、`Function`、`Symbol`

`**default**`：默认值；对象或者数组应当用工厂函数返回

`**required**`：是否必填，布尔值

`**validator**`：自定义校验，函数类型



对象形式声明 props【选项式】

对象形式声明 props【组合式】

例子：  

需要注册的组件 Button.vue【选项式】

父组件使用 Button.vue 组件【选项式】

需要注册的组件 Button.vue【组合式】

父组件使用 Button.vue 组件【组合式】

**注意：**

1.  所有`**prop**`默认都是可选的，除非声明了`**required: true**`
2.  除`**Boolean**`外的未传递的可选`**prop**`将会有一个默认值`**undefined**`
3.  `**Boolean**`类型的未传递`**prop**`将被转换为`**false**`；
4.  当`**prop**`的校验失败后，Vue 会抛出一个控制台警告【在开发模式下】
5.  注意`**prop**`的校验是在组件实例被创建之前

1.  在选项式 API 中，实例的属性（比如`**data**`、`**computed**`等) 将在`**default**`或`**validator**`函数中不可用
2.  在组合式 API 中，`**defineProps**`宏中的参数不可以访问`**<script setup>**`中定义的其他变量，因为在编译时整个表达式都会被移到外部的函数中


**特别提醒：**

关于`**Boolean**`类型转换：

为了更贴近原生`boolean attributes`的行为，声明为`Boolean`类型的`props`有特别的类型转换规则

如声明时：`defineProps({ **error**: **Boolean** })`

传递数据时：

-   `<**MyComponent** **error****/>**`：相当于 `<MyComponent :error="true" />`
-   `<**MyComponent />**`：相当于 `<MyComponent :error="false" />`



## 7.3：组件事件【子 -> 父】

有的时候，父组件在使用子组件时，子组件如何给父组件传值呢？

1.  子组件声明自定义的事件
2.  子组件中触发自定义事件（可传值）
3.  父组件使用子组件时监听对应的自定义事件，并执行父组件中的函数（获取子组件传递的值）



### 7.3.1：【子组件】声明组件事件

1.  在选项式 API 中，子组件可通过`**emits**`选项来声明自定义的事件
2.  在组合式 API 中，子组件可通过`**defineEmits()**`宏来声明自定义的事件

### 7.3.1：【子组件】声明组件事件

1.  在选项式 API 中，子组件可通过`**emits**`选项来声明自定义的事件
2.  在组合式 API 中，子组件可通过`**defineEmits()**`宏来声明自定义的事件

#### 7.3.1.1：字符串数组式声明自定义事件  
采用字符串数组可以声明简单的自定义事件：  

数组式自定义事件【选项式】

数组式自定义事件【组合式】


#### 7.3.1.2：对象式声明自定义事件  
采用对象式声明自定义事件，还可以进行校验传递的参数是否符合预期要求  
对象式声明自定义事件中，属性名为自定义事件名，属性值则是是否验证传递的参数：  
1.  属性值为null则不需要验证  
2. 属性值为函数时，参数为传递的数据，函数返回true则验证通过，返回false则验证失败，验证失败可以用警告语句提示开发者【注意：无论是true还是false都会继续执行下去的，父组件都会获取到传递的值】  

对象式自定义事件【选项式】

对象式自定义事件【组合式】


#### 7.3.2：【子组件】触发组件事件  
在选项式 API 中，可通过组件当前实例this.$emit(event, ...args)来触发当前组件自定义的事件  
在组合式 API 中，可调用defineEmits宏返回的emit(event, ...args)函数来触发当前组件自定义的事件  
其中上方两个参数分别为：  
●event：触发事件名，字符串类型  
●...args：传递参数，可没有，可多个  

Button.vue 触发自定义事件【选项式】

Button.vue 触发自定义事件【组合式】



#### 7.3.3：【父组件】监听子组件自定义事件  
使用v-on:event="callback"或者@event="callback"来监听子组件是否触发了该事件  
1event：事件名字（camelCase 形式命名的事件，在父组件中可以使用kebab-case形式来监听）  
2callback：回调函数，如果子组件触发该事件，那么在父组件中执行对应的回调函数，回调函数声明参数可自动接收到触发事件传来的值  

监听子组件自定义事件【选项式】

监听子组件自定义事件【组合式】




#### 7.3.4：组件事件例子  

##### 7.3.4.1：字符串数组式声明自定义事件  

子组件 Student.vue【选项式】

父组件 App.vue【选项式】

子组件 Student.vue【组合式】

父组件 App.vue【组合式】
 
##### 7.3.4.2：对象式声明自定义事件  

子组件 Student.vue【选项式】

父组件 App.vue【选项式】

子组件 Student.vue【组合式】

父组件 App.vue【组合式】



## 7.4：透传属性和事件  

### 7.4.1：如何“透传属性和事件”  
父组件在使用子组件的时候，如何“透传属性和事件”给子组件呢？  
1透传属性和事件并没有在子组件中用props和emits声明  
2透传属性和事件最常见的如@click和class、id、style  
3当子组件只有一个根元素时，透传属性和事件会自动添加到该根元素上；如果根元素已有class或style属性，它会自动合并  

父组件 APP.vue【选项式】

父组件 APP.vue【组合式】

子组件 Chip.vue


渲染的结果：

![[Pasted image 20230417221859.png]]


### 7.4.2：如何禁止“透传属性和事件”

1.  当子组件_**只有一个根元素时**_，透传属性和事件会自动添加到该根元素上，那怎么阻止呢？
2.  在选项式 API 中，你可以在组件选项中设置`**inheritAttrs: false**`来阻止；
3.  在组合式 API 的`<script setup>`中，你需要一个额外的`<script>`块来书写`**inheritAttrs: false**`选项声明来禁止


父组件 App.vue【选项式】

子组件 Chip.vue【选项式】

父组件 App.vue【组合式】

子组件 Chip.vue【组合式】


### 7.4.3：多根元素的“透传属性和事件”

多根节点的组件并没有自动“透传属性和事件”的行为，由于`Vue`不确定要将“透传属性和事件”透传到哪里，所以我们需要`**v-bind="$attrs"**`来显式绑定，否则将会抛出一个运行时警告
父组件 App.vue【选项式】

父组件 App.vue【组合式】

子组件 Chip.vue


### 7.4.4：访问“透传属性和事件”

1.  在选项式 API 中，我们可通过`**this.$attrs**`来访问“透传属性和事件”
2.  在组合式 API 中的`<script setup>`中引入`**useAttrs()**`来访问一个组件的“透传属性和事件”


父组件 App.vue【选项式】

子组件 Chip.vue【选项式】

父组件 App.vue【组合式】

子组件 Chip.vue【组合式】


**注意：**

-   虽然这里的`attrs`对象总是反映为最新的“透传属性和事件”，但它并不是响应式的 (考虑到性能因素)，你不能通过侦听器去监听它的变化
-   如果你需要响应性，可以使用`prop`或者你也可以使用`onUpdated()`使得在每次更新时结合最新的`attrs`执行副作用



## 7.5：插槽

在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段，为此 vue 提供了组件的插槽

### 7.5.1：什么是插槽

在封装组件时，可以使用`<slot>`元素把不确定的、希望由用户指定的部分定义为插槽；插槽可以理解为给预留的内容提供占位符

插槽也可以提供默认内容，如果组件的使用者没有为插槽提供任何内容，则插槽内的默认内容会生效

**注意：**如果在封装组件时没有预留任何`<slot>`插槽，用户提供传递一些模板片段将会被遗弃


![[Pasted image 20230417222107.png]]

父组件 App.vue【选项式】

父组件 App.vue【组合式】

子组件 Card.vue


### 7.5.2：具名插槽

1.  如果在封装组件时需要预留多个插槽节点，则需要为每个`<slot>`插槽指定具体的`name`名称，这种带有具体名称的插槽叫做“具名插槽”
2.  没有指定`name`名称的插槽，会有隐含的名称叫做 `default`
3.  在`<template>`元素上使用 `v-slot:slotName`或者`#slotName`向指定的具名插槽提供内容


父组件 App.vue【选项式】

父组件 App.vue【组合式】

子组件 Card.vue

### 7.5.3：作用域插槽

如何在向插槽提供的内容时获得子组件域内的数据呢？

1.  在声明插槽时使用属性值的方式来传递子组件的数据，这种带有数据的插槽称之为作用域插槽
2.  在`<template>`元素上使用`v-slot:slotName="slotProps"`或`#slotName="slotProps"`的方式来访问插槽传递属性值
3.  如果没有使用`<template>`元素，而是直接在使用子组件中直接给默认插槽提供内容，我们可以在使用该子组件时用`v-slot="slotProps"`来接收该插槽传递的数据对象

**注意：**`<slot>`插槽上的`name`是一个`Vue`特别保留的属性，不会在作用域插槽中访问到

父组件 App.vue【选项式】

子组件 Card.vue【选项式】

父组件 App.vue【组合式】

子组件 Card.vue【组合式】



## 7.6：单文件组件`CSS`功能

默认情况下，写在`.vue`组件中的样式会全局生效，很容易造成多个组件之间的样式冲突问题

导致组件之间样式冲突的根本原因是：

1.  单页面应用程序中，所有组件的`DOM`结构，都是基于唯一的`index.html`页面进行呈现的
2.  每个组件中的样式，都会影响整个`index.html`页面中的`DOM`元素


### 7.6.1：组件作用域`CSS`

当`<style>`标签带有`scoped`属性的后：

1.  它的`CSS`只会影响当前组件的元素，父组件的样式将不会渗透到子组件中
2.  该组件的所有元素编译后会自带一个特定的属性
3.  该`<style scoped>`内的选择器，在编译后会自动添加特定的属性选择器
4.  子组件的根节点会同时被父组件的作用域样式和子组件的作用域样式影响，主要是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式

转换前

转换后



案列：  

父组件 App.vue【选项式】

父组件 App.vue【组合式】

子组件 Button.vue



### 7.6.2：深度选择器  
处于scoped样式中的选择器如果想要做更“深度”的选择，即影响到子组件，可以使用:deep()这个伪类  

编译前

编译后


### 7.6.2：深度选择器

处于`scoped`样式中的选择器如果想要做更“深度”的选择，即影响到子组件，可以使用`:deep()`这个伪类

编译前

编译后



### 7.6.3：`CSS`中的`v-bind()`

1.  单文件组件的`<style>`标签支持使用`v-bind``CSS`函数将`CSS`的值链接到动态的组件状态
2.  这个语法同样也适用于`<script setup>`，且支持`JavaScript`表达式（需要用引号包裹起来）
3.  实际的值会被编译成哈希化的`CSS`自定义属性，因此`CSS`本身仍然是静态的
4.  自定义属性会通过内联样式的方式应用到组件的某个元素上，并且在源值变更的时候响应式地更新

**案列：**

CSS 中的 v-bind 函数【选项式】

CSS 中的 v-bind 函数【组合式】


## 7.7：依赖注入

如果有一个深层的子组件需要一个较远的祖先组件中的部分数据，如果实现呢？

1.  可使用`props`沿着组件链逐级传递下去，如图 7.1

![[Pasted image 20230417222449.png]]

2.  我们可在祖先组件使用`provide`提供数据，后代组件使用`inject`注入数据，如图 7.2

![[Pasted image 20230417222457.png]]


### 7.7.1：`provide`(提供)

**在应用层如何提供****：**

在应用层方面可通过`app.provide()`为后代提供数据


应用层提供数据

```vue
import { createApp } from 'vue'
const app = createApp({ })
app.provide('message', 'hello!') // message 注入名， 'hello' 值
```


**在组件中如何提供**

1.  在选项式 API 中，可通过`provide`选项为后代提供数据
Provide 选项提供数据【选项式】
```
export default {
    // 为后代组件提供数据选项
    provide: { title: '博客!' } // message：注入名，'hello'：值
}
```

2.  如果想访问到组件的实例`this`，`provide`必须采用函数的方式（不能用箭头函数），为保证注入方和供给方之间的响应性链接，必须借助组合式 API 中的`computed()`函数提供计算属性，还可以提供修改响应式数据的函数（响应式数据的修改，尽量放在同一个组件中，为了好维护）

Provide 函数选项提供数据【选项式】
```
export default {
    data: () => ({
        title: '博客',
        subtitle: '百万博主分享经验'
    }),
    methods: {
        changeSubtitle(sub) {
            this.subtitle = sub
        }
    },
    // 使用函数的形式，可以访问到组件的实例 `this`
    provide() {
        return {
            // 传递数据的值为数据源 title，此方式注入方和供给方之间没有响应性链接
            title: this.title,
            // 传递数据的值为数据源 subtitle，此方式注入方和供给方之间具有响应性链接
            subtitle: computed(() => this.subtitle),
            // 为后代组件提供修改响应式数据 subtitle 的函数
            changeSubtitle: this.changeSubtitle
        }
	}
}

```

在组合式 API `<script setup>` 中，可通过`provide()`函数来为后代组件提供数据
使用 provide 函数提供数据
```
<script setup>
import { ref, provide } from 'vue'

const message = 'hello'
const title = ref('博客')
const subtitle = ref('百万博主分享经验')

function changeSubtitle(sub) {
    this.subtitle = sub
}

provide('message', message) // 提供固定数据
provide('title', title) // 提供响应式数据
provide('subtitle', subtitle) // 提供响应式数据
provide('changeSubtitle', changeSubtitle) // 为后代组件提供修改响应式数据 subtitle 的函数
</script>
```

**注意：**`provide`选项中通过`computed`函数提供的响应式的数据，需要设置`app.config.unwrapInjectedRef = true`以保证注入会自动解包这个计算属性。这将会在 Vue 3.3 后成为一个默认行为，而我们暂时在此告知此项配置以避免后续升级对代码的破坏性。在 3.3 后就不需要这样做了。

### 7.7.2：`inject`(注入)
1.  **在选项式 API 中**，可通过`inject`选项来声明需要注入祖先组件提供的数据，他们可以在`JS`中直接通过`this`来访问，在视图模板中也可直接访问

```
export default {
    // 注入祖先组件提供的数据
    inject: ['message', 'title', 'subtitle', 'changeSubtitle'] 
}
```

2.  `inject`采用对象的形式来注入祖先组件提供的数据有哪些好处？

1.  可用本地属性名注入祖先组件提供的数据（如相同时，`from`选项可省略）
2.  如果注入的数据并没有在祖先组件中提供，则会抛出警告，可采用`defalut`选项设置默认值来解决


inject 对象形式【选项式】
```
export default {
    // 注入祖先组件提供的数据
    inject: {
        c_message: { 
            from: 'message', // 注入的哪个数据
        },
        // 本地属性名和需要注入的数据名一致时，from 可省略
        title, // 普通数据
        c_subtitle: {from: 'subtitle'}, // 响应式数据
        c_changeSub: {from: 'changeSubtitle'}, // 修改响应式数据 subtitle 的函数
        c_content: {
            from: 'content', // 祖先组件并未提供 content，则会报警告
            default: '暂时还未有内容' // 设置默认值（可为函数等），解决警告问题
        } 
    }
}
```


**在组合式 API 中**，使用`inject()`函数的返回值来注入祖先组件提供的数据

1.  如果提供数据的值是一个`ref`，注入进来的会是该`ref`对象，和提供方保持响应式连接
2.  如果注入的数据并没有在祖先组件中提供，则会抛出警告，可在`provide()`函数的第二个参数设置默认值来解决
3.  他们可以在`JS`和视图模板中直接访问
```
<script setup>
import { inject } from 'vue'

const c_message = inject('message')
const title = inject('title')
const c_subtitle = inject('subtitle')
const c_changeSub = inject('changeSubtitle')
// 祖先组件并未提供 content，则会报警告，设置默认值来解决
const c_content = inject('content',  '暂时还未有内容') 
</script>
```
### 7.2.3：例子

main.js

Vue

复制代码

App.vue【选项式】

Footer.vue【选项式】

DeepChild.vue【选项式】

App.vue【组合式】

Footer.vue【组合式】

DeepChild.vue【组合式】





