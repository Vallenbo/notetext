在电脑上安装完以下软件或服务：

1.  NodeJs
2.  VsCode  + Volar安装或者WebStorm
3.  在`Microsoft Edge`浏览器访问 [Microsoft Edge Addons](https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home?hl=zh-CN) 搜索 `vue devtools`获取并添加扩展
## 新建项目

```bash
cd <your-project-name> //切换到项目目录
npm create vue@3 //启动 Vite 驱动的 Vue 项目的推荐方法
npm install  //安装项目依赖，node_modules
npm run dev  //运行该项目
npm run build  //将应用发布到生产环境
```

## 目录结构
-   `.vscode ` 			//vscode工具的配置文件夹
-   `node_modules`		//Vue项目的运行依赖文件夹
-   `public`				//资源文件夹(浏览器图标)
-   `src`				//源码文件夹
-   `gitignore`			//git忽略文件
-   `index.htm]`			//单页面程序唯一的界面文件
-   `package.json`		//信息描述文件
-   `README. md`			//注释文件
-   `vite.config.js`		//Vue配置文件
-   `App.vue`：			//用来编写待渲染的模板结构，也成为根组件
-   `main.js`：			//项目的主入口文件，把 App.vue 渲染到了 index.html 中

# 简介

## 1.1：什么是 Vue

`Vue`是一款用于构建用户界面的`JavaScript`框架；它基于标准 `HTML`、`CSS`和 `JavaScript`构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面

## 1.2：MVVM 工作原理

MVVM 指的是`**Model**`、`**View**`和`**ViewModel**`

-   `Model`：页面渲染用到的数据源
-   `View`：页面所渲染的 DOM 结构
-   `ViewModel`：表示 vue 的实例
![[Pasted image 20230417211555.png]]
-   当数据源发生变化时，会被 VM 监听到，VM 会根据最新的数据源自动更新页面的结构
-   当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中
## 1.3：Vue 的组件风格书写
Vue 的组件可以按两种不同的风格书写
-   选项式 API
```vue
<script> <!-- 脚本区域 -->
    export default { // vue 实例对象（viewModel）
        data: () => ({ // 数据源存放到 data 节点中（model）
            account: 'Abc'
        }),
        methods: { // 方法节点
            changeAccount() {
                this.account += "="
            }
        }
    }
</script>

<template>
    <input type="text" v-model="account">  <!-- 使用数据源得 DOM -->
    <button @click="changeAccount">点我打印数据源 account</button>
</template>
```
-   组合式 API
```vue
<script setup>
    import { ref } from 'vue' // 引入 API 函数
    let account = ref('Abc') // 数据源
    function chageAccount() { // 方法
        account.value += '='
    }
</script> 

<template> <!-- 视图区域（view） -->
    <input type="text" v-model="account"> <!-- 使用数据源得 DOM -->
    <button @click="chageAccount">点我更改account</button>
</template>
```

### 1.3.1：选项式 API

-   使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如`data`、`methods`和 `mounted`
-   选项所定义的属性都会暴露在函数内部的`this`上，它会指向当前的组件实例

### 1.3.2：组合式 API

-   通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑
-   在单文件组件中，组合式 API 通常会与`<script setup>`搭配使用
-   这个`setup`属性是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API
-   `<script setup>`中的导入和顶层变量/函数都能够在模板中直接使用

# 3：响应式数据

## 3.1：选项式 API 的响应式数据

-   可用`data`选项来声明组件的响应式状态；该`data`选项的值应为返回一个对象的函数；
-   `data`函数返回对象的所有顶层属性都会被代理到组件实例（即方法和生命周期钩子中的 `this`）上

```vue
<script>
    export default {
        data: () => ({ // data 选项的值应该是一个函数返回的对象
            account: 'Abc',
            student: {
                name: 'Jack',
                age: 30
            }
        }),
        methods: {
            changeAccount() {
                // 取出数据源可通过 this（当前组件得实例对象） 关键字获取
                this.account += '='
            },
            changeStudentAge() {
                this.student.age ++
            }
        }
    }
</script>

<template>
    <h1>账号：{{ account }}</h1>
    <button @click="changeAccount">点我更改账号</button>
    <hr>
    <h1>学生：{{ student }}</h1>
    <button @click="changeStudentAge">点我更改学生年龄</button>
</template>
```

## 3.2：组合式 API 的响应式数据

如果在组合式 API 中直接声明普通变量的数据源，他们并不具备响应式数据
```vue
<script setup>
    let account = 123 // 普通的变量不具备响应式
    function changeAccount() {
        account+= 1
        console.log(account)
    }

    let emp = { // 普通类型的对象，不具备响应式
        salary: 7000,
        name: 'Annie'
    }
    function changeEmpSalary() {
        emp.salary += 100
        console.log(emp)
    }
</script>

<template>
    <h1>账号：{{ account }}</h1>
    <button @click="changeAccount">点我更改账号</button>
    <hr>
    <h1>员工：{{ emp }}</h1>
    <button @click="changeEmpSalary">点我更改薪资</button>
</template>
```

### 3.2.1：`reactive()` 函数

`reactive()`函数只对对象类型有效（对象、数组、`Map`、`Set`），对`string`、`number`和 `boolean`这样的原始类型无效
```vue
<script setup>
    import { reactive } from 'vue'  // 引入 reactive 函数
    
    let account = reactive('Abc') // reactive 对原始类型是无效（不具备响应式）
    function changeAccount() {
        account += '='
        console.log(account)
    }

    let emp = reactive({ // reactive 对象数据源（具有响应式）
        name: 'Jack',
        salary: 7000
    })
    function changeEmpSalary() {
        emp.salary += 1
        console.log(emp)
    }
</script>

<template>
    <hr>
    <h1>账号：{{ account }}</h1>
    <button @click="changeAccount">点我更改账号</button>

    <hr>
    <h1>员工：{{ emp }}</h1>
    <button @click="changeEmpSalary">点我更改员工薪资</button>
</template>

```
### 3.2.2：`ref()` 函数

-   使用`ref()`方法我们可以创建任何类型的响应式数据，获取时需要通过`.value`来进行获取
-   当值为对象类型时，会用`reactive()`自动转换它的 `.value`
```vue
<script setup>
    import { ref } from 'vue' // 引入 ref 函数，来声明响应式对象
    
    let account = ref('Abc') // 使用 ref 函数来声明原始类型的数据源，具备响应式
    function changeAccount() { // 更改账号，控制台查看最新值
        // 通过 ref 函数声明的响应式数据，需要使用 .value 来获取数据的值
        account.value += '='
        console.log(account)
    }

    let emp = ref({ // 使用 ref 函数来声明对象类型的数据源：具备响应式
        salary: 7000,
        name: 'Jack'
    })
    function changeEmpSalary() { // 更改员工薪资，控制台查看最新值
        emp.value.salary += 100 // 通过 ref 函数声明的响应式数据，需要使用 .value 来获取数据的值
        console.log(emp)
    }
</script>

<template>
    <h1>账号：{{ account }}</h1>
    <button @click="changeAccount">点我更改账号</button>

    <hr>
    <h1>员工：{{ emp }}</h1>
    <button @click="changeEmpSalary">点我更改员工薪资</button>
</template>
```




#  ============文本插值

通过{{}}进行传递

```vue
<template>
    <h3>模板语法 </h3>
    <p> {{ msg }}</p>
</template>

<script>
export default {
    data() {
        return {
            msg: "神奇的语法"
        }
    }
}
</script>
```

# 属性绑定

```vue
<dev v-bind:msg>测试</dev>
return {msg: "active", dynamicID: "appID"}
```

### 简写

因为 `v-bind` 非常常用，我们提供了特定的简写语法：template

```vue
<div :id="dynamicId"></div>
```

# 布尔型 Attribute

[布尔型 attribute](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes#布尔值属性) 依据 true / false 值来决定 attribute 是否应该存在于该元素上。[`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled) 就是最常见的例子之一。

`v-bind` 在这种场景下的行为略有不同：template

```
<button :disabled="isButtonDisabled">Button</button>
```


---

# 动态绑定多个属性值

如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：js

```vue
data() {
  return {
    objectOfAttrs: { //对象
      id: 'container',
      class: 'wrapper'
    }
  }
}
```

通过不带参数的 `v-bind`，你可以将它们绑定到单个元素上：template

```
<div v-bind="objectOfAttrs"></div>
```

# 条件绑定



## `v-if`

指令是带有 `v-` 前缀的特殊 attribute。Vue 提供了许多[内置指令](https://cn.vuejs.org/api/built-in-directives.html)，包括上面我们所介绍的 `v-bind` 和 `v-html`。

指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 `v-for`、`v-on` 和 `v-slot`)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 [`v-if`](https://cn.vuejs.org/api/built-in-directives.html#v-if) 为例：template

```
<p v-if="seen">Now you see me</p>
```

这里，`v-if` 指令会基于表达式 `seen` 的值的真假来移除/插入该 `<p>` 元素。

## `v-else-if`

顾名思义，`v-else-if` 提供的是相应于 `v-if` 的“else if 区块”。它可以连续多次重复使用：template

```
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```

## `v-show`

另一个可以用来按条件显示一个元素的指令是 `v-show`。其用法基本一样：

template

```
<h1 v-show="ok">Hello!</h1>
```

不同之处在于 `v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的 CSS 属性。

`v-show` 不支持在 `<template>` 元素上使用，也不能和 `v-else` 搭配使用。

**if和show比较**

`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适。

# 列表渲染

## `v-for`

我们可以使用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令的值需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据的数组，而 `item` 是迭代项的**别名**：js

```vue
data() {
  return {
    items: [{ message: 'Foo' }, { message: 'Bar' }]
  }
}
```

```vue
<li v-for="item in items"> //in关键字可以改成of
  {{ item.message }}
</li>
```

**支持索引**

```vue
    items: [{ message: 'Foo' }, { message: 'Bar' }]
```

**遍历map**

```
<li v-for="(value,key, index) of userinfo">
        {{ value }} - {{ key }} - {{ index }}
    </li>
```

## 通过 key 管理状态

Vue 默认按照“就地更新”的策略来更新通过 `v-for` 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。

默认模式是高效的，但**只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况**。

为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 `key` attribute：template

```
<div v-for="item in items" :key="item.id">
  <!-- 内容 -->
</div>
```

当你使用 `<template v-for>` 时，`key` 应该被放置在这个 `<template>` 容器上：template

```
<template v-for="todo in todos" :key="todo.name">
  <li>{{ todo.name }}</li>
</template>
```

# 事件处理

## 监听事件

我们可以使用 `v-on` 指令 (简写为 `@`) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：`v-on:click="handler"` 或 `@click="handler"`。

事件处理器 (handler) 的值可以是：

1. **内联事件处理器**：事件被触发时执行的内联 JavaScript 语句 (与 `onclick` 类似)。
2. **方法事件处理器**：一个指向组件上定义的方法的属性名或是路径。

**内联事件处理器**

内联事件处理器通常用于简单场景，例如：js

```vue
data() {
  return {
    count: 0
  }
}
```

```vue
<button @click="count++">Add 1</button>
<p>Count is: {{ count }}</p>
```

**方法事件处理器**

随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 `v-on` 也可以接受一个方法名或对某个方法的调用。举例来说：js

```vue
data() {
  return {
    name: 'Vue.js'
  }
},
methods: {
  greet(event) {
    // 方法中的 `this` 指向当前活跃的组件实例
    alert(`Hello ${this.name}!`)
    // `event` 是 DOM 原生事件
    if (event) {
      alert(event.target.tagName)
    }
  }
}
```

```vue
<!-- `greet` 是上面定义过的方法名 -->
<button @click="greet">Greet</button>
```

## 在内联处理器中调用方法

除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：js

```
methods: {
  say(message) {
    alert(message)
  }
}
```

template
```
<button @click="say('hello')">Say hello</button>
<button @click="say('bye')">Say bye</button>
```



























