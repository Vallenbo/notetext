## 4.1：内容渲染指令

内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容

### 4.1.1：`v-text`

使用`v-text`指令，将数据采用纯文本方式填充其空元素中

```vue
<script> //v-text【选项式】
export default {
    data: () => ({
        student: {
            name: 'Jack',
            desc: '<h3>我是来自中国的小朋友！</h3>'
        }
    })
}
</script>

<script setup> //v-text【选项式】
    import { reactive } from 'vue'

    let student = reactive({
        name: 'Jack',
        desc: '<h3>我是来自中国的小朋友！</h3>'
    })
</script>

<template>
    <!-- 使用v-text指令，将数据采用纯文本方式填充其空元素中 -->
    <div v-text="student.name"></div>
    <!-- v-text：以纯文本的方式显示数据 -->
    <div v-text="student.desc"></div>
    <!-- 下面的代码会报错：div 元素不是空元素 -->
    <!-- <div v-text="student.name">这是原始的div数据</div> -->
</template>
```

### 4.1.2：`{{ }}`插值表达式

在元素中的某一位置采用纯文本的方式渲染数据
```vue
<script>  //{{ }} 插值表达式【选项式】
export default {
    data: () => ({
        student: {
            name: 'Jack',
            desc: '<h3>我是来自中国的小朋友！</h3>'
        }
    })
}
</script>

<script setup> //{{ }} 插值表达式【组合式】
import { reactive } from 'vue'

let student = reactive({
    name: 'Jack',
    desc: '<h3>我是来自中国的小朋友！</h3>'
})
</script>

<template>
    <!-- 插值表达式：在元素中的某一位置采用纯文本的方式渲染数据 -->
    <div>这是一个 DIV 元素，{{ student.name }}，{{ student.desc }}</div>
</template>
```

### 4.1.3：`v-html`

使用`v-html`指令，将数据采用HTML语法填充其空元素中
```vue
<script>
export default { //v-html【选项式】
    data: () => ({
        student: {
            name: 'Jack',
            desc: '<h3>我是来自中国的小朋友！</h3>'
        }
    })
}
</script>

<script setup> //v-html【组合式】
import { reactive } from 'vue'

let student = reactive({
    name: 'Jack',
    desc: '<h3>我是来自中国的小朋友！</h3>'
})
</script>


<template>
    <!-- 使用v-html指令，将数据采用HTML语法填充其空元素中 -->
    <div v-html="student.name"></div>
    <!-- v-html：以 HTML 语法显示数据 -->
    <div v-html="student.desc"></div>
    <!-- 下面的代码会报错：div 元素不是空元素 -->
    <!-- <div v-html="student.name">这是原始的div数据</div> -->
</template>
```

## 4.2：双向绑定指令

### 4.2.1：`v-model`

`v-model`双向数据绑定指令，视图数据和数据源同步

一般情况下`v-model`指令用在表单元素中：
1.  文本类型的`<input>`和`<textarea>`元素会绑定`value`属性并侦听`input`事件
2.  `<input type="checkbox">`和`<input type="radio">`会绑定`checked`属性并侦听`change`事件
3.  `<select>`会绑定`value`属性并侦听`change`事件


```vue

```



### 4.2.2：`v-model`的修饰符
![[Pasted image 20230417214658.png]]



## 4.3：属性绑定指令

-   响应式地绑定一个元素属性，应该使用`v-bind:`指令
-   如果绑定的值是`null`或者`undefined`，那么该属性将会从渲染的元素上移除
-   因为`v-bind`非常常用，我们提供了特定的简写语法`:`


### 4.3.1：动态绑定多个属性值

直接使用`v-bind`来为元素绑定多个属性及其值


渲染结果：

`<button class="redBack" id="btnBorderBlue">我是一个普通按钮</button>`



### 4.3.2：绑定`class`和`style`属性

`class`和`style`可以和其他属性一样使用`v-bind`将它们和动态的字符串绑定；但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的；因此，`Vue`专门为`class`和`style`的`v-bind`用法提供了特殊的功能增强；除了字符串外，表达式的值也可以是对象或数组。

#### 4.3.2.1：`class`属性绑定

**绑定对象**


**绑定数组**




#### 4.3.2.2：`style`属性绑定

**绑定对象**



**绑定数组**

还可以给`:style`绑定一个包含多个样式对象的数组，这些对象会被合并后渲染到同一元素上



style 属性绑定数组（选项式 API 例子）



style 属性绑定数组（组合式 API 例子）

## 4.4：条件渲染指令

### 4.4.1：`v-if`、`v-else-if`、`v-else`

1.  `v-if` 指令用于条件性地渲染元素；该内容只会在指令的表达式返回真值时才被渲染
2.  `v-else-if`提供的是相应于`v-if`的`else if`区块，它可以连续多次重复使用
3.  你也可以使用`v-else`为`v-if`添加一个`else`区块
4.  `v-else`和`v-else-if`指令必须配合`v-if`指令一起使用 ，否则它将不会被识别，而且语句块中间不能出现无关其他元素
5.  `v-if`支持在`<template>`元素上使用，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 `<template>`元素



v-if、v-else-if、v-else【选项式】



v-if、v-else-if、v-else【组合式】



### **4.4.2：**`**v-show**`

-   `v-show`按条件显示一个元素的指令
-   `v-show`会在 DOM 渲染中保留该元素
-   `v-show`仅切换了该元素上名为`display`的 CSS 属性
-   `v-show`不支持在`<template>`元素上使用，也不能和`v-else`搭配使用


v-show【选项式】




v-show【组合式】


### **4.4.3：**`**v-if**`**和**`**v-show**`**的区别**

-   `v-if`是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建
-   `v-if`也是惰性的：如果在初次渲染时条件值为`false`，则不会做任何事；条件区块只有当条件首次变为`true`时才被渲染
-   `v-show`元素无论初始条件如何，始终会被渲染，只有 CSS`display`属性会被切换
-   `v-if`有更高的切换开销，而`v-show`有更高的初始渲染开销；如果需要频繁切换，则使用`v-show` 较好；如果在运行时绑定条件很少改变，则`v-if`会更合适

## 4.5：事件绑定指令

我们可以使用`**v-on:**`指令 (简写为`**@**`) 来监听 DOM 事件，并在事件触发时执行对应的`JavaScript`

用法：`**v-on:click=""**`或 `**@click=""**`


事件绑定指令【选项式】




事件绑定指令【组合式】



### 4.5.1：事件修饰符

- 事件修饰符 说明
**.prevent**     **阻止默认行为**
**.stop** **阻止事件冒泡**
**.capture** **以捕获模式触发当前的事件处理函数**
**.once** **绑定的事件只触发1次**
**.self** **只有在**`**event.target**`**是当前元素自身时触发事件处理函数**
**.passive** **向浏览器表明了不想阻止事件的默认行为**

### 4.5.2：按键修饰符

按键别名：`.enter`、`.tab`、`.esc`、`.space`、`.up`、`.down`、`.left`、`.right`、`.delete` (捕获`Delete`和`Backspace`两个按键)

系统修饰符：`.ctrl`、`.alt`、`.shift`、`.meta`

准确的修饰符：`.exact`




### 4.5.3：鼠标按键修饰符

鼠标按键修饰符：`.left`、`.right`、`.middle`



## 4.6：列表渲染指令

使用`v-for`指令基于一个数组来渲染一个列表


### 4.6.1：`v-for`渲染数组

语法：

1.  `in`前一个参数：`item in items`  
    `item`：值  
    `items`：需要循环的数组
2.  `in`前两个参数：`(value, index) in items`  
    `value`：值  
    `index`：索引  
    `items`：需要循环的数组


### 4.6.2：`v-for`渲染对象

使用`v-for`来遍历一个对象的所有属性，遍历的顺序会基于对该对象调用`Object.keys()`的返回值来决定

语法：

1.  `in`前一个参数：`value in object`  
    `value`：属性值  
    `items`：需要循环的对象
2.  `in`前两个参数：`(value, name) in object`  
    `value`：属性值  
    `name`：键  
    `items`：需要循环的对象
3.  `in`前三个参数：`(value, name, index) in object`  
    `value`：属性值  
    `name`：键  
    `index`：索引  
    `items`：需要循环的对象


### 4.6.3：通过 key 管理状态

当列表的数据变化时，默认情况下，`vue`会尽可能的复用已存在的`DOM`元素，从而提升渲染的性能；但这种默认的性能优化策略，会导致有状态的列表无法被正确更新。

为了给`vue`一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲染的性能；此时，需要为每项提供一个唯一的`key`属性：

`key`的注意事项：

-   `key`的类型只能是`Number/String`
-   `key`值必须具有唯一性
-   建议循环的列表有一个属性当`key`（该属性的值在此列表中唯一）
-   不使用索引当`key`
-   建议使用`v-for`指令时一定要指定`key`的值





