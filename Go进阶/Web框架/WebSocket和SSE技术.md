# 为什么需要 WebSocket？

我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？

- 因为 HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力。比如，我们想了解查询今天的实时数据，只能是客户端向服务器发出请求，服务器返回查询结果。

- HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。


在WebSocket出现之前，我们只能使用"轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源。

**传统的实现即时通信的方式**

> **ajax轮询**
> ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。ajax轮询 需要服务器有很快的处理速度和资源。

> **long poll（长轮询）**
> long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。long poll 需要有很高的并发，也就是说同时接待客户的能力。

在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖HTTP协议，进行不停的轮询，这会导致一些问题：

- 服务端被迫维持来自每个客户端的大量不同的连接
- 大量的轮询请求会造成高开销。

因为http协议本身是没有持久通信能力的，但是我们在实际的应用中，是很需要这种能力的，所以为了解决这些问题，WebSocket 协议由此而生。

# 什么是 WebSocket

WebSocket协议是 **基于TCP** 的一种新的网络协议。它实现了浏览器与服务器全双工（full-duplex）通信，**即允许服务器主动发送信息给客户端**。因此，在WebSocket中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，客户端和服务器之间的数据交换变得更加简单。

> **什么是单工、半双工、全工通信？**
>
> 信息只能单向传送为单工；
> 信息能双向传送但不能同时双向传送称为半双工；
> 信息能够同时双向传送则称为全双工。

在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。

WebSocket 本质上一种计算机网络应用层的协议，用来弥补 http 协议在持久通信能力上的不足。现在最新版本浏览器都已经支持了。

> WebSocket 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。
>

WebSocket 的其他特点包括：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
（3）数据格式比较轻量，性能开销小，通信高效。
（4）可以发送文本，也可以发送二进制数据。
（5）没有同源限制，客户端可以与任意服务器通信。
（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

# WebSocket协议的原理

WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。它的主要目的是在 Web 浏览器和服务器之间提供一种低延迟、双向通信的方式，克服了传统 HTTP 请求 / 响应模式的局限性。

以下是 WebSocket 协议的原理：

**一、建立连接**

1. 客户端发起请求：
   - 客户端（通常是 Web 浏览器）向服务器发送一个 HTTP 请求，请求升级到 WebSocket 连接。这个请求包含一些特殊的头部信息，如 `Connection: Upgrade` 和 `Upgrade: websocket`，表明客户端希望将连接升级为 WebSocket。
   - 还包括一个 `Sec-WebSocket-Key` 头部，它是一个随机生成的字符串，用于验证连接的合法性。
2. 服务器响应：
   - 服务器如果支持 WebSocket，会返回一个 HTTP 响应，状态码为 101（Switching Protocols），表示同意升级连接。
   - 响应中也包含一些特殊的头部信息，如 `Connection: Upgrade` 和 `Upgrade: websocket`，以及一个 `Sec-WebSocket-Accept` 头部，它是根据客户端发送的 `Sec-WebSocket-Key` 计算得到的，用于验证服务器的合法性。

**二、数据传输**

1. 连接建立后，双方可以通过这个单一的 TCP 连接进行全双工通信。
   - 数据以帧的形式传输，WebSocket 定义了多种帧类型，包括文本帧、二进制帧、控制帧等。
   - 每个帧都有一个特定的格式，包括帧的类型、长度、数据等信息。
2. 数据格式：
   - WebSocket 数据可以是文本格式（UTF-8 编码）或二进制格式。
   - 文本格式通常用于传输可读的字符串数据，而二进制格式可以用于传输任何类型的二进制数据，如图像、音频、视频等。

**三、保持连接和控制**

1. 心跳机制：
   - 为了保持连接的活跃性，WebSocket 可以使用心跳机制。客户端和服务器可以定期发送心跳帧，以确保对方仍然在线。如果一方在一段时间内没有收到心跳响应，就可以认为连接已经断开，并采取相应的措施。
2. 关闭连接：
   - 任何一方都可以通过发送一个关闭帧来关闭连接。关闭帧包含一个关闭代码和一个可选的关闭原因说明。
   - 另一方收到关闭帧后，会返回一个关闭响应，确认连接已经关闭。

WebSocket 的优点包括低延迟、实时性好、双向通信、较少的开销等，因此在实时应用程序中得到了广泛的应用，如在线聊天、实时游戏、股票行情推送等。

# gorilla库构建ws服务

用`Go`自带的`net/http`库实现`WebSocket`服务还是太复杂了。好在有很多对`WebSocket`支持良好的第三方库，能减少我们很多底层的编码工作。

这里我们使用`gorilla web toolkit`家族的另外一个库`gorilla/websocket`来实现我们的`WebSocket`服务，构建一个简单的`Echo`服务（`echo`意思是回音，就是客户端发什么，服务端再把消息发回给客户端）。

`github.com/gorilla/websocket`：这是一个非常流行的 Go WebSocket 库。它提供了强大的功能，包括连接管理、消息处理、心跳检测等。

```go
go get github.com/gorilla/websocket
```
使用示例
```go
var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true
    },
}

func echo(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err!= nil {
        log.Println(err)
        return
    }
    defer conn.Close()

    for {
        messageType, p, err := conn.ReadMessage()
        if err!= nil {
            log.Println(err)
            break
        }
        fmt.Printf("Received: %s\n", p)
        err = conn.WriteMessage(messageType, p)
        if err!= nil {
            log.Println(err)
            break
        }
    }
}

func main() {
    http.HandleFunc("/echo", echo)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

在这个示例中，创建了一个 WebSocket 服务器，当客户端连接到`/echo`路径时，服务器会升级连接为 WebSocket 连接。然后，服务器会不断接收客户端发送的消息，并将消息回显给客户端。

注意，这个示例中的`CheckOrigin`设置为总是返回`true`，在实际应用中，你应该根据实际情况进行适当的跨域检查以确保安全性。

# SSE

严格地说，HTTP 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。

也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。

SSE 就是利用这种机制，使用流信息向浏览器推送信息（如新闻推送）。它基于 HTTP 协议。

## SSE 的特点

SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。

总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。

**优点**

- SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。
- SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。
- SSE 默认支持断线重连，WebSocket 需要自己实现。
- SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。
- SSE 支持自定义发送的消息类型。
